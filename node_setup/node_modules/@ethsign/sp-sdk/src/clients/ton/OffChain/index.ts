import { ChainType } from '../../../types';
import { OffChainClientBase } from '../../../interface/OffChainClientBase';
import { TonOffChainClientOptions } from '../types';
import { KeyPair, sign } from '@ton/crypto';
import { WalletContractV5R1, WalletContractV4, Address } from '@ton/ton';
import { sha256 } from '@noble/hashes/sha256';
import { Buffer } from 'buffer';
import { TonConnectUI, Wallet, WalletInfo } from '@tonconnect/ui';
export class TonOffChainClient extends OffChainClientBase {
  public walletClient!: TonConnectUI;
  public keyPair?: KeyPair;
  public address?: string;
  private proofAnchor?: number;

  constructor(options: TonOffChainClientOptions) {
    super({
      chainType: ChainType.ton,
      signType: options.signType,
      apiKey: options.apiKey,
      rpcUrl: options.rpcUrl,
    });
    if ('walletClient' in options) {
      this.walletClient = options.walletClient;
    } else {
      if (options.account && !options.walletAddress) {
        throw new Error('walletAddress is required when account is provided');
      }
      this.keyPair = options.account;
      this.address = options.walletAddress;
    }
  }

  public async getAccount() {
    if (this.keyPair) {
      const publicKey = this.keyPair.publicKey;
      const walletV5 = await WalletContractV5R1.create({
        publicKey: publicKey,
        workchain: 0,
      });
      const addressV5 = walletV5.address.toString({ bounceable: false });

      const walletV4 = await WalletContractV4.create({
        publicKey: publicKey,
        workchain: 0,
      });
      const addressV4 = walletV4.address.toString({ bounceable: false });
      if (addressV4 !== this.address && addressV5 !== this.address) {
        throw new Error('walletAddress is not match with account');
      }
      return {
        address: this.address,
        publicKey: this.keyPair.publicKey.toString('hex'),
      };
    } else {
      const { address, publicKey } = this.walletClient.account || {};
      const parsedAddress = Address.parse(address!).toString({
        bounceable: false,
      });
      return {
        address: parsedAddress,
        publicKey,
      };
    }
  }

  async signMessage(
    message: string
  ): Promise<{ signature: string; message: string; publicKey: string }> {
    const hash = sha256(message);
    const payload = Buffer.from(hash).toString('hex');
    let signature;
    let fullMessage;
    if (this.keyPair) {
      fullMessage = {
        timestamp: Math.floor(Date.now() / 1000),
        payload,
        domain: {
          lengthBytes: 11,
          value: 'sign.global',
        },
      };
      const fullMessageForTonConnect = buildFullMessageForTonConnect(
        Address.parse(this.address!),
        fullMessage
      );

      signature = await sign(fullMessageForTonConnect, this.keyPair.secretKey);
    } else if (this.walletClient) {
      this.proofAnchor = Date.now();
      this.walletClient.setConnectRequestParameters({
        state: 'ready',
        value: {
          tonProof: payload,
        },
      });
      const currentAppName = (this.walletClient.wallet as any)?.appName;
      const wallets = await this.walletClient.getWallets();
      const currentWallet = wallets.find((wallet) =>
        [wallet.name, wallet.appName].includes(currentAppName)
      ) as WalletInfo;
      if (this.walletClient.wallet) {
        await this.walletClient.disconnect();
      }
      if (currentAppName) {
        const universalLink = this.walletClient.connector.connect(
          currentWallet,
          {
            tonProof: payload,
          }
        );
        if (currentAppName === 'telegram-wallet') {
          window.open(universalLink as string, '_blank');
        }
      } else {
        this.walletClient.openModal();
      }
      const proof: any = await new Promise((resolve, reject) => {
        const proofAnchor = this.proofAnchor;
        return this.walletClient.onStatusChange(
          (walletInfo: Wallet | null) => {
            let tonProof: any = walletInfo?.connectItems?.tonProof;
            if (tonProof?.proof && proofAnchor === this.proofAnchor) {
              resolve(tonProof?.proof);
            } else {
              reject('wallet modal closed');
            }
          },
          (err) => {}
        );
      });
      signature = proof.signature;
      fullMessage = {
        timestamp: proof.timestamp,
        payload: proof.payload,
        domain: proof.domain,
      };
    } else {
      throw new Error('No wallet client found');
    }
    const account = await this.getAccount();
    // 将签名转换为Base64或十六进制字符串
    return {
      signature: signature.toString('base64'),
      message: JSON.stringify(fullMessage),
      publicKey: account.publicKey!,
    };
  }

  signTypedData(data: {
    message: { [key: string]: any };
    types: { [key: string]: { name: string; type: string }[] };
    primaryType: string;
  }): Promise<{ message: any; signature: string; publicKey: string }> {
    throw new Error('Method not implemented for TON.');
  }
}

function buildFullMessageForTonConnect(
  addr: Address,
  message: {
    timestamp: number;
    payload: string;
    domain: {
      lengthBytes: number;
      value: string;
    };
  }
): Buffer {
  const tonProofPrefix = 'ton-proof-item-v2/';
  const tonConnectPrefix = 'ton-connect';

  const wc = Buffer.alloc(4);
  wc.writeUInt32BE(addr.workChain);

  const ts = Buffer.alloc(8);
  ts.writeBigUInt64LE(BigInt(message.timestamp));

  const dl = Buffer.alloc(4);
  dl.writeUInt32LE(message.domain.lengthBytes);

  const m = Buffer.concat([
    Buffer.from(tonProofPrefix),
    wc,
    addr.hash,
    dl,
    Buffer.from(message.domain.value),
    ts,
    Buffer.from(message.payload),
  ]);

  const messageHash = sha256(m);

  const fullMes = Buffer.concat([
    Buffer.from([0xff, 0xff]),
    Buffer.from(tonConnectPrefix),
    Buffer.from(messageHash),
  ]);

  const res = sha256(fullMes);
  return Buffer.from(res);
}
