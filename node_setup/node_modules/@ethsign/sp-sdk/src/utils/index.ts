import { decodeAbiParameters, encodeAbiParameters } from 'viem';

import {
  DataLocationOffChain,
  DataLocationOnChain,
  OnChainSchema,
  SchemaItemOffChain,
  SchemaItemOnChain,
} from '../types';
import { AbiType } from 'abitype';
import { getOffChainStorageData, saveDataToStorage } from '../services';

export function request(url: string, options?: RequestInit) {
  const defaultOptions = {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
    },
    mode: 'cors' as RequestMode,
  };

  const requestOptions = {
    ...defaultOptions,
    ...options,
    headers: {
      ...defaultOptions.headers,
      ...options?.headers,
    },
  };

  // 发送请求
  return fetch(url, requestOptions)
    .then(async (response) => {
      if (!response.ok) {
        // 尝试解析错误响应体
        let errorData;
        try {
          errorData = await response.json();
        } catch (e) {
          // 如果无法解析为JSON，则使用文本内容
          try {
            errorData = { message: await response.text() };
          } catch (textError) {
            errorData = { message: `HTTP error! status: ${response.status}` };
          }
        }

        // 创建一个包含更多错误信息的Error对象
        const error = new Error(
          errorData.message || `HTTP error! status: ${response.status}`
        );
        (error as any).status = response.status;
        (error as any).statusText = response.statusText;
        (error as any).errorData = errorData;
        throw error;
      }
      return response.json();
    })
    .catch((error) => {
      console.error('Request failed:', error);
      throw error;
    });
}

export function validateObject(
  obj: any,
  fields: (SchemaItemOnChain | SchemaItemOffChain)[]
): boolean {
  const objFields = Object.keys(obj).map((key) => ({
    name: key,
    type: typeof obj[key],
  }));

  if (fields.length !== objFields.length) {
    throw new Error(`Field length does not match`);
  }

  return fields.every((rule) => {
    const objField = objFields.find((field) => field.name === rule.name);

    if (!objField) {
      throw new Error(`Field ${rule.name} is required`);
    }
    if (typeof rule.type === 'string') {
      return true;
    } else if (Array.isArray(rule.type)) {
      // 嵌套结构检查（仅支持一层）
      if (typeof obj[rule.name] !== 'object' || obj[rule.name] === null) {
        throw new Error(`Field ${rule.name} must be an object`);
      }
      return validateObject(obj[rule.name], rule.type); // 递归验证一层嵌套
    } else {
      throw new Error(`Invalid rule type for field ${rule.name}`);
    }
  });
}

export function encodeOnChainData(
  data: any,
  dataLocation: DataLocationOnChain,
  schemaData: SchemaItemOnChain[]
): string {
  return encodeAbiParameters<any>(
    dataLocation === DataLocationOnChain.ONCHAIN
      ? schemaData
      : [{ type: 'string' }],
    dataLocation === DataLocationOnChain.ONCHAIN
      ? (schemaData as SchemaItemOnChain[]).map(
          (item: any) =>
            (
              data as {
                [key: string]: any;
              }
            )[item.name]
        )
      : [data]
  );
}

export function decodeOnChainData(
  data: any,
  dataLocation: DataLocationOnChain,
  schemaData: SchemaItemOnChain[]
): any {
  const newSchemaData = schemaData.map((item) => {
    if (item.storage === 'arweave') {
      return { name: item.name, type: 'string' };
    }
    return item;
  }) as { name: string; type: AbiType }[];
  try {
    const decodeData = decodeAbiParameters(
      [
        dataLocation === DataLocationOnChain.ONCHAIN
          ? { components: newSchemaData, type: 'tuple' }
          : { type: 'string' },
      ],
      data
    );
    return decodeData[0];
  } catch (error) {
    const decodeData = decodeAbiParameters(
      dataLocation === DataLocationOnChain.ONCHAIN
        ? newSchemaData
        : [{ type: 'string' }],
      data
    );
    const obj: any = {};
    schemaData.forEach((item, i) => {
      obj[item.name] = decodeData[i];
    });
    return obj;
  }
}

export const stringifyQueryString = (obj: Record<string, any>): string => {
  return Object.entries(obj)
    .filter(([_, value]) => value !== null && value !== '') // 跳过 null 和空字符串
    .map(
      ([key, value]) =>
        `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`
    )
    .join('&');
};
export const parseQuery = (params: string): Record<string, any> => {
  return params
    .replace(/^\?/, '') // 去掉开头的 `?`
    .split('&') // 按 `&` 分割键值对
    .filter((pair) => pair) // 跳过空项
    .reduce((acc, pair) => {
      const [key, value] = pair.split('=');
      acc[decodeURIComponent(key)] = decodeURIComponent(value || '');
      return acc;
    }, {} as Record<string, any>);
};

export async function uploadStorageData({
  data,
  schema,
  apiKey,
  dataLocation,
}: {
  data: any;
  schema: OnChainSchema;
  apiKey?: string;
  dataLocation?: DataLocationOnChain;
}): Promise<any> {
  const schemaData = schema.data;
  if (typeof schemaData === 'string') {
    return { data, schema: schemaData };
  }
  let newData = { ...data };
  let newSchemaData = [...schemaData];
  if (dataLocation !== DataLocationOnChain.ONCHAIN) {
    const storageType =
      dataLocation === DataLocationOnChain.ARWEAVE
        ? DataLocationOffChain.ARWEAVE
        : DataLocationOffChain.IPFS;
    newData = await saveDataToStorage(
      JSON.stringify(data),
      storageType,
      apiKey
    );
  } else {
    await Promise.all(
      newSchemaData.map(async (item, i) => {
        if (item.storage) {
          newData[item.name] = await saveDataToStorage(
            JSON.stringify(newData[item.name]),
            item.storage,
            apiKey
          );
          newSchemaData[i].type = 'string';
        }
      })
    );
  }
  return { data: newData, schemaData: newSchemaData };
}

export async function getStorageData({
  data,
  schema,
  dataLocation,
}: {
  data: any;
  schema: OnChainSchema;
  dataLocation?: DataLocationOnChain;
}): Promise<any> {
  const schemaData = schema.data;
  if (typeof schemaData === 'string') {
    return { data, schema: schemaData };
  }
  let newData = { ...data };
  if (dataLocation === DataLocationOnChain.ARWEAVE) {
    newData = data;

    newData = await getOffChainStorageData({
      storageType: 'arweave',
      dataId: newData,
    });
  } else {
    await Promise.all(
      schemaData.map(async (item, i) => {
        if (item.storage === 'arweave') {
          newData[item.name] = await getOffChainStorageData({
            storageType: 'arweave',
            dataId: newData[item.name],
          });
        }
      })
    );
  }
  return { data: newData };
}

export function isBrowser() {
  return typeof window !== 'undefined';
}
