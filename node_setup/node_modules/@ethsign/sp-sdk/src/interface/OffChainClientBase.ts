import { isAddress } from 'viem';
import { SignProtocolClientBase } from './SignProtocolClientBase';
import { OffChainRpc } from '../types/offChain';
import {
  Attestation,
  AttestationResult,
  ChainType,
  DataLocationOffChain,
  OffChainSignType,
  RevokeAttestationResult,
  Schema,
  SchemaItemOffChain,
  SchemaResult,
} from '../types';
import { request, validateObject } from '../utils';
import { throwApikeyError } from '../utils/tools';

export abstract class OffChainClientBase implements SignProtocolClientBase {
  rpcUrl: OffChainRpc | string;
  chainType: ChainType;
  signType: OffChainSignType;
  apiKey: string;
  constructor({
    chainType,
    signType,
    rpcUrl,
    apiKey,
  }: {
    chainType: ChainType;
    signType: OffChainSignType;
    rpcUrl?: OffChainRpc | string;
    apiKey: string;
  }) {
    this.rpcUrl = rpcUrl || OffChainRpc.mainnet;
    this.signType = signType;
    this.chainType = chainType;
    this.apiKey = apiKey;
  }

  async revokeAttestation(
    attestationId: string,
    options?: {
      reason?: string | undefined;
    }
  ): Promise<RevokeAttestationResult> {
    if (!this.apiKey) {
      throwApikeyError();
    }
    const { reason } = options || {};

    let publicKey;
    const signType = this.signType;
    const revokeAttestationObj = {
      attestationId,
      reason: reason || '',
    };
    const revokeAttestationString = JSON.stringify(revokeAttestationObj);
    let signature = '';
    let message = revokeAttestationString;
    if (signType === OffChainSignType.EvmEip712) {
      const info = await this.signTypedData({
        message: revokeAttestationObj,
        types: {
          Data: [
            { name: 'attestationId', type: 'string' },
            { name: 'reason', type: 'string' },
          ],
        },
        primaryType: 'Data',
      });
      signature = info.signature;
      message = JSON.stringify(info.message);
      publicKey = info.publicKey;
    } else {
      const res = await this.signMessage(revokeAttestationString);
      signature = res.signature;
      message = res.message;
      publicKey = res.publicKey;
    }
    const url = this.rpcUrl + '/sp/revoke-attestation';
    try {
      const res = await request(url, {
        method: 'POST',
        headers: {
          'x-sign-api-key': this.apiKey || '',
        },
        body: JSON.stringify({
          signType,
          publicKey,
          signature,
          message,
          revokeInfo: revokeAttestationString,
        }),
      });
      if (res) {
        return { attestationId, reason };
      } else {
        throw new Error('revoke attestation failed');
      }
    } catch (error: any) {
      // 传递后端返回的具体错误信息
      if (error.errorData) {
        throw error;
      }
      throw new Error('revoke attestation failed');
    }
  }

  abstract getAccount(): Promise<{ address: string; publicKey?: string }>;
  abstract signTypedData(data: {
    message: { [key: string]: any };
    types: { [key: string]: { name: string; type: string }[] };
    primaryType: string;
  }): Promise<{ message: any; signature: string; publicKey: string }>;
  abstract signMessage(
    message: string
  ): Promise<{ signature: string; message: string; publicKey: string }>;
  async createSchema(schema: Schema): Promise<SchemaResult> {
    if (!this.apiKey) {
      throwApikeyError();
    }

    let publicKey;
    const signType = this.signType;
    const {
      name,
      description,
      revocable,
      maxValidFor,
      data,
      dataLocation = DataLocationOffChain.ARWEAVE,
    } = schema;
    const schemaObj = {
      name: name || '',
      description: description || '',
      revocable: revocable === undefined ? true : revocable,
      maxValidFor: maxValidFor || 0,
      types: data,
      dataLocation,
    };
    const schemaString = JSON.stringify(schemaObj);
    let signature = '';
    let message = schemaString;
    if (signType === OffChainSignType.EvmEip712) {
      const info = await this.signTypedData({
        message: schemaObj,
        types: {
          Data: [
            { name: 'name', type: 'string' },
            { name: 'description', type: 'string' },
            { name: 'revocable', type: 'bool' },
            { name: 'maxValidFor', type: 'uint32' },
            { name: 'dataLocation', type: 'string' },
            { name: 'types', type: 'SchemaItem[]' },
          ],
          SchemaItem: [
            { name: 'name', type: 'string' },
            { name: 'type', type: 'string' },
          ],
        },
        primaryType: 'Data',
      });
      signature = info.signature;
      message = JSON.stringify(info.message);
      publicKey = info.publicKey;
    } else {
      const res = await this.signMessage(schemaString);
      signature = res.signature;
      message = res.message;
      publicKey = res.publicKey;
    }
    const url = this.rpcUrl + '/sp/schemas';
    const res = await request(url, {
      method: 'POST',
      headers: {
        'x-sign-api-key': this.apiKey || '',
      },
      body: JSON.stringify({
        signType,
        publicKey,
        signature,
        message,
        schema: schemaString,
      }),
    });
    return res.data;
  }

  async getSchema(schemaId: string): Promise<Schema> {
    const url = this.rpcUrl + '/sp/schemas/' + schemaId;
    const res = await request(url, {
      method: 'GET',
    });
    if (!res.data) {
      throw new Error('schema not found');
    }
    const {
      name,
      description,
      revocable,
      dataLocation,
      maxValidFor,
      resolver,
      data,
    } = res.data;
    const result: Schema = {
      name,
      description,
      revocable,
      dataLocation,
      maxValidFor,
      resolver,
      data,
    };

    return result;
  }
  async createAttestation(
    attestation: Attestation
  ): Promise<AttestationResult> {
    if (!this.apiKey) {
      throwApikeyError();
    }

    let publicKey;
    const signType = this.signType;
    const {
      schemaId,
      linkedAttestationId,
      validUntil,
      recipients,
      indexingValue,
      data,
      dataLocation = DataLocationOffChain.ARWEAVE,
    } = attestation;
    const attestationObj = {
      schemaId,
      linkedAttestationId: linkedAttestationId || '',
      validUntil: validUntil || 0,
      recipients: recipients || [],
      indexingValue,
      dataLocation,
      data: JSON.stringify(data),
    };
    const attestationString = JSON.stringify(attestationObj);
    const schema = await this.getSchema(schemaId);
    const schemaData = schema?.data;
    if (!schema) {
      throw new Error('schema not found');
    }
    if (!validateObject(data, schemaData as SchemaItemOffChain[])) {
      throw new Error('data is not valid');
    }
    let signature = '';
    let message = attestationString;
    if (signType === OffChainSignType.EvmEip712) {
      let isRecipientAddress = true;
      recipients?.forEach((recipient) => {
        if (!isAddress(recipient)) {
          isRecipientAddress = false;
        }
      });
      const info = await this.signTypedData({
        message: attestationObj,
        types: {
          AttestationData: schemaData as SchemaItemOffChain[],
          Data: [
            { name: 'schemaId', type: 'string' },
            { name: 'linkedAttestationId', type: 'string' },
            { name: 'data', type: 'string' },
            { name: 'validUntil', type: 'uint32' },
            {
              name: 'recipients',
              type: isRecipientAddress ? 'address[]' : 'string[]',
            },
            {
              name: 'indexingValue',
              type: isAddress(indexingValue) ? 'address' : 'string',
            },
          ],
        },
        primaryType: 'Data',
      });
      signature = info.signature;
      message = JSON.stringify(info.message);
      publicKey = info.publicKey;
    } else {
      const res = await this.signMessage(attestationString);
      signature = res.signature;
      message = res.message;
      publicKey = res.publicKey;
    }
    const url = this.rpcUrl + '/sp/attestations';

    const res = await request(url, {
      method: 'POST',
      headers: {
        'x-sign-api-key': this.apiKey || '',
      },
      body: JSON.stringify({
        signType,
        publicKey,
        signature,
        message,
        attestation: attestationString,
      }),
    });

    return res.data;
  }

  async getAttestation(attestationId: string): Promise<Attestation> {
    const url = this.rpcUrl + '/index/attestations/' + attestationId;
    const res = await request(url, {
      method: 'GET',
    });
    if (!res.data) {
      throw new Error('attestation not found');
    }
    const {
      schemaId,
      linkedAttestationId,
      data,
      validUntil,
      revoked,
      recipients,
      indexingValue,
    } = res.data;
    const result: Attestation = {
      schemaId,
      linkedAttestationId,
      data: data ? JSON.parse(data) : data,
      validUntil,
      revoked,
      recipients,
      indexingValue,
    };
    return result;
  }
}
