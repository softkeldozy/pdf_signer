"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVMOnChainClient = void 0;
const viem_1 = require("viem");
const types_1 = require("../../../types");
const utils_1 = require("../../../utils");
const types_2 = require("../types");
const constants_1 = require("../constants");
const SignProtocol_json_1 = __importDefault(require("./abi/SignProtocol.json"));
const services_1 = require("../../../services");
class EVMOnChainClient {
    walletClient;
    publicClient;
    contractInfo;
    privateKeyAccount;
    chain;
    account;
    apiKey;
    constructor({ chain: chainType, rpcUrl: rpc, account: privateKeyAccount, walletClient, apiKey, }) {
        this.apiKey = apiKey;
        this.contractInfo = chainType
            ? constants_1.ContractInfoMap[chainType]
            : constants_1.ContractInfoMap[types_2.EvmChains.sepolia];
        const chain = {
            ...this.contractInfo?.chain,
            rpcUrls: rpc
                ? {
                    default: {
                        http: [rpc],
                    },
                }
                : this.contractInfo?.chain.rpcUrls,
        };
        this.chain = chain;
        // @ts-ignore
        this.publicClient = (0, viem_1.createPublicClient)({
            chain,
            transport: (0, viem_1.http)(),
        });
        this.walletClient =
            walletClient ||
                (0, viem_1.createWalletClient)({
                    chain,
                    transport: privateKeyAccount
                        ? (0, viem_1.http)()
                        : (0, utils_1.isBrowser)() && window.ethereum
                            ? (0, viem_1.custom)(window.ethereum)
                            : (0, viem_1.http)(),
                });
        this.privateKeyAccount = privateKeyAccount;
    }
    async signMessage(message) {
        const account = await this.getAccount();
        return await this.walletClient.signMessage({
            account: this.privateKeyAccount ? account : account.address,
            message: { raw: message },
        });
    }
    async switchChain() {
        const walletChainId = await this.walletClient.getChainId();
        if (walletChainId !== this.chain.id) {
            try {
                await this.walletClient.switchChain({
                    id: this.chain.id,
                });
            }
            catch (error) {
                if (error?.code !== 4001) {
                    await this.walletClient.addChain({
                        chain: this.chain,
                    });
                    await this.walletClient.switchChain({
                        id: this.chain.id,
                    });
                }
            }
        }
    }
    async getAccount() {
        let account;
        if (this.privateKeyAccount) {
            account = this.privateKeyAccount;
        }
        else {
            const accounts = await this.walletClient.getAddresses();
            account = { address: accounts[0] };
        }
        return account;
    }
    async invokeContractRead(functionName, args = []) {
        try {
            return this.publicClient.readContract({
                address: this.contractInfo.address,
                abi: SignProtocol_json_1.default.abi,
                functionName,
                args,
            });
        }
        catch (error) {
            console.error(error.message);
            throw error;
        }
    }
    async invokeContractWrite(functionName, args = [], value, abi, gas) {
        try {
            const account = await this.getAccount();
            await this.switchChain();
            const data = {
                account: this.privateKeyAccount ? account : account.address,
                address: this.contractInfo.address,
                abi: abi || SignProtocol_json_1.default.abi,
                functionName,
                args,
                value,
                chain: this.chain,
                gas,
            };
            const { request } = await this.publicClient.simulateContract(data);
            return this.walletClient.writeContract(request);
        }
        catch (error) {
            console.error(error.message);
            throw error;
        }
    }
    async createSchema(schema, options) {
        const { revocable, maxValidFor, resolver, hook, data, name, description, registrant, } = schema;
        const account = await this.getAccount();
        const dataLocation = schema.dataLocation || types_1.DataLocationOnChain.ONCHAIN;
        const { delegationSignature, getTxHash, gas } = options || {};
        let newData = data;
        if (dataLocation !== types_1.DataLocationOnChain.ONCHAIN) {
            newData = await (0, services_1.saveSchemaToStorage)({
                data,
                name,
                description,
                dataLocation: dataLocation === types_1.DataLocationOnChain.ARWEAVE
                    ? types_1.DataLocationOffChain.ARWEAVE
                    : types_1.DataLocationOffChain.IPFS,
                apiKey: this.apiKey,
            });
        }
        const txHash = await this.invokeContractWrite('register', [
            {
                registrant: registrant || account.address,
                revocable: revocable === undefined ? true : revocable,
                dataLocation: dataLocation,
                maxValidFor: maxValidFor || 0,
                hook: hook || resolver || '0x0000000000000000000000000000000000000000',
                timestamp: 0,
                data: dataLocation === types_1.DataLocationOnChain.ONCHAIN
                    ? JSON.stringify({ name, description, data: newData })
                    : newData,
            },
            delegationSignature || '',
        ], undefined, undefined, gas);
        getTxHash && getTxHash(txHash);
        const res = await this.publicClient.waitForTransactionReceipt({
            hash: txHash,
        });
        const decodedLog = (0, viem_1.decodeEventLog)({
            abi: SignProtocol_json_1.default.abi,
            topics: res.logs[0].topics,
            data: res.logs[0].data,
        });
        const schemaId = (0, viem_1.numberToHex)(decodedLog.args.schemaId);
        return { schemaId, txHash };
    }
    async getSchema(schemaId) {
        const res = await this.invokeContractRead('getSchema', [schemaId]);
        if (res.data === '') {
            throw new Error('schema not found');
        }
        const { revocable, dataLocation, maxValidFor, resolver, hook, data, timestamp, } = res;
        const isOnChain = dataLocation === types_1.DataLocationOnChain.ONCHAIN;
        let dataObj;
        if (isOnChain) {
            dataObj = JSON.parse(data);
        }
        else if (dataLocation === types_1.DataLocationOnChain.ARWEAVE ||
            dataLocation === types_1.DataLocationOnChain.IPFS) {
            const res = await (0, services_1.getDataFromStorage)({ dataId: data, dataLocation });
            dataObj = res.data;
        }
        const result = {
            name: dataObj.name,
            description: dataObj.description,
            revocable,
            dataLocation,
            timestamp: Number(timestamp),
            maxValidFor: Number(maxValidFor),
            hook: hook || resolver,
            data: dataObj.data,
            registrant: res.registrant,
        };
        return result;
    }
    async revokeAttestation(attestationId, options) {
        const { reason, delegationSignature, getTxHash, resolverFeesETH, extraData, resolverFeesERC20Token, resolverFeesERC20Amount, gas, } = options || {};
        const params = [
            attestationId,
            reason || '',
            delegationSignature || '',
            extraData || '',
        ];
        const revokeAbis = SignProtocol_json_1.default.abi.filter((item) => item.name === 'revoke');
        let revokeAbi = [revokeAbis[0]];
        if (resolverFeesERC20Token && resolverFeesERC20Amount) {
            params.splice(2, 0, resolverFeesERC20Token, resolverFeesERC20Amount);
            revokeAbi = [revokeAbis[1]];
        }
        if (resolverFeesETH) {
            params.splice(2, 0, resolverFeesETH);
            revokeAbi = [revokeAbis[2]];
        }
        const txHash = await this.invokeContractWrite('revoke', params, resolverFeesETH, [...revokeAbi, ...SignProtocol_json_1.default.abi], gas);
        getTxHash && getTxHash(txHash);
        const res = await this.publicClient.waitForTransactionReceipt({
            hash: txHash,
        });
        const decodedLog = (0, viem_1.decodeEventLog)({
            abi: SignProtocol_json_1.default.abi,
            topics: res.logs[0].topics,
            data: res.logs[0].data,
        });
        const id = (0, viem_1.numberToHex)(decodedLog.args.attestationId);
        return { attestationId: id, txHash, reason: decodedLog.args.reason };
    }
    async createAttestation(attestation, options) {
        const { schemaId, linkedAttestationId, data, validUntil, revoked, recipients, indexingValue, attester, attestTimestamp, revokeTimestamp, } = attestation;
        const { delegationSignature, getTxHash, resolverFeesETH, recipientEncodingType, extraData, resolverFeesERC20Token, resolverFeesERC20Amount, gas, } = options || {};
        const dataLocation = attestation.dataLocation || types_1.DataLocationOnChain.ONCHAIN;
        let attestationData;
        if (delegationSignature) {
            attestationData = {
                schemaId,
                linkedAttestationId,
                data,
                validUntil: BigInt(validUntil || 0),
                revoked,
                recipients,
                attester,
                dataLocation,
                attestTimestamp,
                revokeTimestamp,
            };
        }
        else {
            const account = await this.getAccount();
            if (!attestation.schemaId) {
                throw new Error('schemaId is required');
            }
            const schema = await this.getSchema(attestation.schemaId);
            const schemaData = schema?.data;
            if (!schema) {
                throw new Error('schema not found');
            }
            if (!(0, utils_1.validateObject)(data, schemaData)) {
                throw new Error('data is not valid');
            }
            const handledData = await (0, utils_1.uploadStorageData)({
                data,
                schema,
                apiKey: this.apiKey,
                dataLocation,
            });
            attestationData = {
                schemaId,
                linkedAttestationId: linkedAttestationId || '',
                attester: attester || account.address,
                validUntil: BigInt(validUntil || 0),
                revoked: revoked || false,
                dataLocation,
                attestTimestamp: 0,
                revokeTimestamp: 0,
                recipients: recipients?.map((item) => {
                    const isRecipientAddress = (0, viem_1.isAddress)(item);
                    return (0, viem_1.encodeAbiParameters)([
                        {
                            name: 'data',
                            type: isRecipientAddress &&
                                recipientEncodingType === types_1.RecipientEncodingType.Address
                                ? types_1.RecipientEncodingType.Address
                                : types_1.RecipientEncodingType.String,
                        },
                    ], [item]);
                }) || [],
                data: (0, utils_1.encodeOnChainData)(handledData.data, dataLocation, handledData.schemaData),
            };
        }
        const params = [
            attestationData,
            indexingValue || '',
            delegationSignature || '',
            extraData || '',
        ];
        const attestAbis = SignProtocol_json_1.default.abi.filter((item) => item.name === 'attest');
        let attestAbi = [attestAbis[0]];
        if (resolverFeesETH) {
            params.splice(1, 0, resolverFeesETH);
            attestAbi = [attestAbis[2]];
        }
        if (resolverFeesERC20Token && resolverFeesERC20Amount) {
            params.splice(1, 0, resolverFeesERC20Token, resolverFeesERC20Amount);
            attestAbi = [attestAbis[1]];
        }
        const txHash = await this.invokeContractWrite('attest', params, resolverFeesETH, [...attestAbi, ...SignProtocol_json_1.default.abi], gas);
        getTxHash && getTxHash(txHash);
        const res = await this.publicClient.waitForTransactionReceipt({
            hash: txHash,
        });
        const decodedLog = (0, viem_1.decodeEventLog)({
            abi: SignProtocol_json_1.default.abi,
            topics: res.logs[0].topics,
            data: res.logs[0].data,
        });
        const attestationId = (0, viem_1.numberToHex)(decodedLog.args.attestationId);
        return {
            attestationId,
            txHash,
            indexingValue: decodedLog.args.indexingKey,
        };
    }
    async getAttestation(attestationId) {
        const res = await this.invokeContractRead('getAttestation', [
            attestationId,
        ]);
        if (res.data === '0x') {
            throw new Error('attestation not found');
        }
        const schemaId = (0, viem_1.numberToHex)(res.schemaId);
        const schema = await this.getSchema(schemaId);
        const schemaData = schema.data;
        const data = (0, utils_1.decodeOnChainData)(res.data, res.dataLocation, schemaData);
        const handledData = await (0, utils_1.getStorageData)({
            data,
            schema,
            dataLocation: res.dataLocation,
        });
        const recipients = res.recipients.map((item) => {
            let res;
            try {
                res = (0, viem_1.decodeAbiParameters)([{ name: 'data', type: types_1.RecipientEncodingType.String }], item)[0];
            }
            catch (error) {
                res = (0, viem_1.decodeAbiParameters)([{ name: 'data', type: types_1.RecipientEncodingType.Address }], item)[0];
            }
            return res;
        });
        const result = {
            attestTimestamp: Number(res.attestTimestamp),
            revokeTimestamp: Number(res.revokeTimestamp),
            schemaId,
            data: handledData.data,
            recipients,
            revoked: res.revoked,
            dataLocation: res.dataLocation,
            validUntil: Number(res.validUntil),
            linkedAttestationId: '0x' + Number(res.linkedAttestationId).toString(16) || '',
            indexingValue: res.indexingKey,
            attester: res.attester,
        };
        return result;
    }
}
exports.EVMOnChainClient = EVMOnChainClient;
//# sourceMappingURL=index.js.map