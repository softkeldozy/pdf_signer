"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseQuery = exports.stringifyQueryString = void 0;
exports.request = request;
exports.validateObject = validateObject;
exports.encodeOnChainData = encodeOnChainData;
exports.decodeOnChainData = decodeOnChainData;
exports.uploadStorageData = uploadStorageData;
exports.getStorageData = getStorageData;
exports.isBrowser = isBrowser;
const viem_1 = require("viem");
const types_1 = require("../types");
const services_1 = require("../services");
function request(url, options) {
    const defaultOptions = {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
        },
        mode: 'cors',
    };
    const requestOptions = {
        ...defaultOptions,
        ...options,
        headers: {
            ...defaultOptions.headers,
            ...options?.headers,
        },
    };
    // 发送请求
    return fetch(url, requestOptions)
        .then(async (response) => {
        if (!response.ok) {
            // 尝试解析错误响应体
            let errorData;
            try {
                errorData = await response.json();
            }
            catch (e) {
                // 如果无法解析为JSON，则使用文本内容
                try {
                    errorData = { message: await response.text() };
                }
                catch (textError) {
                    errorData = { message: `HTTP error! status: ${response.status}` };
                }
            }
            // 创建一个包含更多错误信息的Error对象
            const error = new Error(errorData.message || `HTTP error! status: ${response.status}`);
            error.status = response.status;
            error.statusText = response.statusText;
            error.errorData = errorData;
            throw error;
        }
        return response.json();
    })
        .catch((error) => {
        console.error('Request failed:', error);
        throw error;
    });
}
function validateObject(obj, fields) {
    const objFields = Object.keys(obj).map((key) => ({
        name: key,
        type: typeof obj[key],
    }));
    if (fields.length !== objFields.length) {
        throw new Error(`Field length does not match`);
    }
    return fields.every((rule) => {
        const objField = objFields.find((field) => field.name === rule.name);
        if (!objField) {
            throw new Error(`Field ${rule.name} is required`);
        }
        if (typeof rule.type === 'string') {
            return true;
        }
        else if (Array.isArray(rule.type)) {
            // 嵌套结构检查（仅支持一层）
            if (typeof obj[rule.name] !== 'object' || obj[rule.name] === null) {
                throw new Error(`Field ${rule.name} must be an object`);
            }
            return validateObject(obj[rule.name], rule.type); // 递归验证一层嵌套
        }
        else {
            throw new Error(`Invalid rule type for field ${rule.name}`);
        }
    });
}
function encodeOnChainData(data, dataLocation, schemaData) {
    return (0, viem_1.encodeAbiParameters)(dataLocation === types_1.DataLocationOnChain.ONCHAIN
        ? schemaData
        : [{ type: 'string' }], dataLocation === types_1.DataLocationOnChain.ONCHAIN
        ? schemaData.map((item) => data[item.name])
        : [data]);
}
function decodeOnChainData(data, dataLocation, schemaData) {
    const newSchemaData = schemaData.map((item) => {
        if (item.storage === 'arweave') {
            return { name: item.name, type: 'string' };
        }
        return item;
    });
    try {
        const decodeData = (0, viem_1.decodeAbiParameters)([
            dataLocation === types_1.DataLocationOnChain.ONCHAIN
                ? { components: newSchemaData, type: 'tuple' }
                : { type: 'string' },
        ], data);
        return decodeData[0];
    }
    catch (error) {
        const decodeData = (0, viem_1.decodeAbiParameters)(dataLocation === types_1.DataLocationOnChain.ONCHAIN
            ? newSchemaData
            : [{ type: 'string' }], data);
        const obj = {};
        schemaData.forEach((item, i) => {
            obj[item.name] = decodeData[i];
        });
        return obj;
    }
}
const stringifyQueryString = (obj) => {
    return Object.entries(obj)
        .filter(([_, value]) => value !== null && value !== '') // 跳过 null 和空字符串
        .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`)
        .join('&');
};
exports.stringifyQueryString = stringifyQueryString;
const parseQuery = (params) => {
    return params
        .replace(/^\?/, '') // 去掉开头的 `?`
        .split('&') // 按 `&` 分割键值对
        .filter((pair) => pair) // 跳过空项
        .reduce((acc, pair) => {
        const [key, value] = pair.split('=');
        acc[decodeURIComponent(key)] = decodeURIComponent(value || '');
        return acc;
    }, {});
};
exports.parseQuery = parseQuery;
async function uploadStorageData({ data, schema, apiKey, dataLocation, }) {
    const schemaData = schema.data;
    if (typeof schemaData === 'string') {
        return { data, schema: schemaData };
    }
    let newData = { ...data };
    let newSchemaData = [...schemaData];
    if (dataLocation !== types_1.DataLocationOnChain.ONCHAIN) {
        const storageType = dataLocation === types_1.DataLocationOnChain.ARWEAVE
            ? types_1.DataLocationOffChain.ARWEAVE
            : types_1.DataLocationOffChain.IPFS;
        newData = await (0, services_1.saveDataToStorage)(JSON.stringify(data), storageType, apiKey);
    }
    else {
        await Promise.all(newSchemaData.map(async (item, i) => {
            if (item.storage) {
                newData[item.name] = await (0, services_1.saveDataToStorage)(JSON.stringify(newData[item.name]), item.storage, apiKey);
                newSchemaData[i].type = 'string';
            }
        }));
    }
    return { data: newData, schemaData: newSchemaData };
}
async function getStorageData({ data, schema, dataLocation, }) {
    const schemaData = schema.data;
    if (typeof schemaData === 'string') {
        return { data, schema: schemaData };
    }
    let newData = { ...data };
    if (dataLocation === types_1.DataLocationOnChain.ARWEAVE) {
        newData = data;
        newData = await (0, services_1.getOffChainStorageData)({
            storageType: 'arweave',
            dataId: newData,
        });
    }
    else {
        await Promise.all(schemaData.map(async (item, i) => {
            if (item.storage === 'arweave') {
                newData[item.name] = await (0, services_1.getOffChainStorageData)({
                    storageType: 'arweave',
                    dataId: newData[item.name],
                });
            }
        }));
    }
    return { data: newData };
}
function isBrowser() {
    return typeof window !== 'undefined';
}
//# sourceMappingURL=index.js.map