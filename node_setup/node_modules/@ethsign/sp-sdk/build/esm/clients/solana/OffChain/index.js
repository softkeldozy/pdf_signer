import { ChainType } from '../../../types';
import { OffChainClientBase } from '../../../interface/OffChainClientBase';
import * as ed from '@noble/ed25519';
import bs58 from 'bs58';
export class SolanaOffChainClient extends OffChainClientBase {
    walletClient;
    keyPair;
    constructor(options) {
        super({
            chainType: ChainType.solana,
            signType: options.signType,
            rpcUrl: options.rpcUrl,
            apiKey: options.apiKey,
        });
        if ('walletClient' in options) {
            this.walletClient = options.walletClient;
        }
        else {
            this.keyPair = options.account;
        }
    }
    async getAccount() {
        if (this.keyPair) {
            const address = this.keyPair.publicKey.toBase58();
            return {
                address: address,
            };
        }
        else {
            return { address: this.walletClient.publicKey.toBase58() };
        }
    }
    async signMessage(message) {
        const messageBytes = new TextEncoder().encode(message);
        const signMessage = this.keyPair
            ? await ed.sign(messageBytes, this.keyPair.secretKey.slice(0, 32))
            : await this.walletClient.signMessage(messageBytes);
        const account = await this.getAccount();
        return {
            signature: bs58.encode(signMessage),
            message: message,
            publicKey: account.address,
        };
    }
    signTypedData(data) {
        throw new Error('Method not implemented.');
    }
}
//# sourceMappingURL=index.js.map