import { PrivateKeyAccount } from 'viem/accounts';
import { EvmChains, EVMOffChainClientOptions } from '../clients/evm/types';
import { WalletClient } from 'viem';
import { AbiType } from 'abitype';
import { SolanaOffChainClientOptions } from '../clients/solana';
import { TonOffChainClientOptions } from '../clients/ton';
import { EVMOnChainClient } from '../clients/evm';
export * from './indexService';
export type ContractInfo = {
    address: Address;
    chain: any;
};
export declare enum DataLocationOnChain {
    ONCHAIN = 0,// only when Mode=OnChain
    ARWEAVE = 1,
    IPFS = 2
}
export declare enum DataLocationOffChain {
    ARWEAVE = "arweave",
    IPFS = "ipfs",
    GREENFIELD = "greenfield",
    GREENFIELD_TESTTNET = "greenfield-testnet"
}
export type DataLocation = DataLocationOnChain | DataLocationOffChain;
export type SignType = OnChainSignType | OffChainSignType;
export declare enum OnChainSignType {
    'eip712' = "eip712"
}
export declare enum OffChainSignType {
    EvmEip712 = "evm-eip712",
    Solana = "solana",
    TonConnect = "ton-connect"
}
export type SchemaItemOnChain = {
    name: string;
    type: AbiType | {
        name: string;
        type: AbiType;
    }[];
    storage?: DataLocationOffChain.ARWEAVE | DataLocationOffChain.IPFS;
};
export type SchemaItemOffChain = {
    name: string;
    type: AbiType;
};
export type SchemaItem = SchemaItemOnChain | SchemaItemOffChain;
export type Address = `0x${string}`;
export type SchemaResult = {
    schemaId: string;
    txHash?: string;
};
export type AttestationResult = {
    attestationId: string;
    indexingValue: string;
    txHash?: string;
};
export declare enum ChainType {
    evm = "evm",
    solana = "solana",
    ton = "ton"
}
export declare enum SpMode {
    OnChain = "OnChain",
    OffChain = "OffChain"
}
export type OnChainClientOptions = {
    chain: EvmChains;
    account?: PrivateKeyAccount;
    rpcUrl?: string;
    walletClient?: WalletClient;
    apiKey?: string;
};
export type OffChainClientOptions = EVMOffChainClientOptions | SolanaOffChainClientOptions | TonOffChainClientOptions;
export type OnChainClient = EVMOnChainClient;
type CommonSchema = {
    name: string;
    description?: string;
    revocable?: boolean;
    maxValidFor?: number;
};
export type OnChainSchema = CommonSchema & {
    /**
     * @deprecated please use `hook` instead
     */
    resolver?: Address;
    hook?: Address;
    registrant?: Address;
    timestamp?: number;
    dataLocation?: DataLocationOnChain;
    data: SchemaItemOnChain[];
};
export type OffChainSchema = CommonSchema & {
    dataLocation?: DataLocationOffChain.ARWEAVE | DataLocationOffChain.IPFS | DataLocationOffChain.GREENFIELD;
    data: SchemaItemOffChain[];
};
/**
 * Schema is a template for Attestations. It defines the structure of the data that can be included in an Attestation, and the rules that apply to it.
 * @typedef Schema
 * @property {string} name - The name of the Schema.
 * @property {string} [description] - The description of the Schema.
 * @property {boolean} [revocable] - Whether Attestations that adopt this Schema can be revoked.
 * @property {DataLocation} [schemaDataLocation] - Where `Schema.data` is stored. See `DataLocation.DataLocation`.
 * @property {DataLocation} [attestationDataLocation] - Where `Schema.data` is stored. See `DataLocation.DataLocation`.
 * @property {number} [maxValidFor] - The maximum number of seconds that an Attestation can remain valid. 0 means Attestations can be valid forever. This is enforced through `Attestation.validUntil`.
 * @property {Address} [resolver] - The `ISPResolver` that is called at the end of every function. 0 means there is no resolver set. See `ISPResolver`.
 * @property {SchemaItem[] | string} data - // when dataLocation=ONCHAIN, data is SchemaItem[], when dataLocation=ARWEAVE or IPFS, data is id of the data,
 */
export type Schema = OnChainSchema | OffChainSchema;
type CommonAttestation = {
    schemaId: string;
    linkedAttestationId?: string | null;
    validUntil?: number;
    revoked?: boolean | null;
    recipients?: string[];
    indexingValue: string;
    attester?: Address;
};
export type OnChainAttestation = CommonAttestation & {
    attestTimestamp?: number;
    revokeTimestamp?: number;
    dataLocation?: DataLocationOnChain;
    data: {
        [key: string]: any;
    };
};
type OffChainAttestation = CommonAttestation & {
    dataLocation?: DataLocationOffChain.ARWEAVE | DataLocationOffChain.IPFS | DataLocationOffChain.GREENFIELD;
    data: {
        [key: string]: any;
    };
};
/**
 * This struct represents an on-chain attestation record. This record is not deleted after revocation.
 * @typedef Attestation
 * @property {string} schemaId - The `Schema` that this Attestation is based on. It must exist.
 * @property {string} [linkedAttestationId] - Useful if the current Attestation references a previous Attestation. It can either be 0 or an existing attestation ID.
 * @property {object} data - The raw data of the Attestation based on `Schema.data`.
 * @property {number} [validUntil] - The expiration timestamp(seconds) of the Attestation. Must respect `Schema.maxValidFor`. 0 indicates no expiration date.
 * @property {boolean} [revoked] - If the Attestation has been revoked. It is possible to make a revoked Attestation.
 * @property {string[]} [recipients] - The intended  recipients of this Attestation.
 * @property {string} indexingValue - The value that is used to index this Attestation.
 */
export type Attestation = OnChainAttestation | OffChainAttestation;
export type AttestationDelegationSignature = {
    attestation: Attestation;
    delegationSignature: `0x${string}`;
};
export type SchemaDelegationSignature = {
    schema: OnChainSchema;
    delegationSignature: `0x${string}`;
};
export type RevokeDelegationSignature = {
    attestationId: string;
    delegationSignature: `0x${string}`;
    reason?: string;
};
export type RevokeAttestationResult = {
    attestationId: string;
    txHash?: string;
    reason?: string;
};
export type AttestationRevokeInfo = {
    attestationId: string;
    revokeReason: string;
};
export declare enum RecipientEncodingType {
    Address = "address",
    String = "string"
}
export type CreateSchemaOnChainOptions = {
    delegationSignature?: string;
    getTxHash?: (txHash: `0x${string}`) => void;
    gas?: bigint;
};
export type CreateAttestationOnChainOptions = {
    resolverFeesETH?: BigInt;
    resolverFeesERC20Token?: `0x${string}`;
    resolverFeesERC20Amount?: BigInt;
    delegationSignature?: string;
    getTxHash?: (txHash: `0x${string}`) => void;
    recipientEncodingType?: RecipientEncodingType;
    extraData?: `0x${string}`;
    gas?: bigint;
};
export type RevokeAttestationOnChainOptions = {
    reason?: string;
    resolverFeesETH?: BigInt;
    resolverFeesERC20Token?: `0x${string}`;
    resolverFeesERC20Amount?: BigInt;
    delegationSignature?: string;
    getTxHash?: (txHash: `0x${string}`) => void;
    extraData?: `0x${string}`;
    gas?: bigint;
};
//# sourceMappingURL=index.d.ts.map