import { useState, useEffect, useCallback } from "react";
import { Buffer } from "buffer";
import { SignProtocolClient, SpMode } from "@ethsign/sp-sdk";
import { createWalletClient, fallback, createPublicClient, http } from "viem";
import { Web3Provider } from "@ethersproject/providers";
import { sepolia } from "viem/chains";

if (typeof window !== "undefined" && !window.Buffer) {
  window.Buffer = Buffer;
}

export default function usePdfSigner2(options = {}) {
  const { file = null, walletAddress = null, metadata = {} } = options;

  const [state, setState] = useState({
    status: "idle",
    signatureData: null,
    error: null,
    documentPreview: null,
    isInitializing: false,
  });

  const prepareDocument = useCallback(
    async (file) => {
      try {
        setState((prev) => ({ ...prev, status: "preparing" }));

        if (
          !file?.type?.includes("pdf") &&
          !file?.name?.toLowerCase().endsWith(".pdf")
        ) {
          throw new Error("Only PDF files are supported");
        }

        if (state.documentPreview) {
          URL.revokeObjectURL(state.documentPreview);
        }

        const previewUrl = URL.createObjectURL(file);
        setState((prev) => ({
          ...prev,
          documentPreview: previewUrl,
          status: "ready_for_approval",
        }));

        return previewUrl;
      } catch (err) {
        setState((prev) => ({
          ...prev,
          status: "error",
          error: {
            message: err.message || "Failed to prepare document",
            details: err.stack,
          },
        }));
        throw err;
      }
    },
    [state.documentPreview]
  );

  // const initializeSDK = useCallback(
  //   async ({
  //     rpcUrl = import.meta.env.VITE_ALCHEMY_SEPOLIA_RPC_URL,
  //     chain = sepolia,
  //   } = {}) => {
  //     try {
  //       if (!rpcUrl) throw new Error("RPC URL is missing from environment");

  //       const publicClient = createPublicClient({
  //         chain,
  //         transport: http(rpcUrl),
  //       });

  //       const provider = new Web3Provider(window.ethereum);
  //       await provider.send("eth_requestAccounts", []);
  //       const signer = await provider.getSigner();

  //       const client = new SignProtocolClient({
  //         mode: SpMode.OnChain,
  //         publicClient,
  //         signer,
  //         chain,
  //       });

  //       return client;
  //     } catch (error) {
  //       console.error("SDK initialization error:", error);
  //       throw new Error(`SDK initialization failed: ${error.message}`);
  //     }
  //   },
  //   []
  // );

  // const initializeSDK = useCallback(async (options) => {
  //   try {
  //     // Ensure options is always an object before destructuring
  //     const {
  //       rpcUrl = import.meta.env.VITE_ALCHEMY_SEPOLIA_RPC_URL,
  //       chain = sepolia,
  //     } = options || {};

  //     if (!rpcUrl) throw new Error("RPC URL is missing from environment");

  //     const publicClient = createPublicClient({
  //       chain,
  //       transport: http(rpcUrl),
  //     });

  //     const provider = new Web3Provider(window.ethereum);
  //     await provider.send("eth_requestAccounts", []);
  //     const signer = await provider.getSigner();

  //     const client = new SignProtocolClient({
  //       mode: SpMode.OnChain,
  //       publicClient,
  //       signer,
  //       chain,
  //     });

  //     return client;
  //   } catch (error) {
  //     console.error("SDK initialization error:", error);
  //     throw new Error(`SDK initialization failed: ${error.message}`);
  //   }
  // }, []);

  const initializeSDK = useCallback(async (opts) => {
    const {
      rpcUrl = import.meta.env.VITE_ALCHEMY_SEPOLIA_RPC_URL,
      chain = sepolia,
    } = opts || {}; // <== safely default if `opts` is undefined

    try {
      if (!rpcUrl) throw new Error("RPC URL is missing from environment");

      const publicClient = createPublicClient({
        chain,
        transport: http(rpcUrl),
      });

      const provider = new Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      const signer = await provider.getSigner();

      const client = new SignProtocolClient({
        mode: SpMode.OnChain,
        publicClient,
        signer,
        chain,
      });

      return client;
    } catch (error) {
      console.error("SDK initialization error:", error);
      throw new Error(`SDK initialization failed: ${error.message}`);
    }
  }, []);

  const signPdf = useCallback(
    async (file, address, metadata = {}) => {
      try {
        setState((prev) => ({ ...prev, status: "signing" }));

        const client = await initializeSDK({
          rpcUrl: import.meta.env.VITE_ALCHEMY_SEPOLIA_RPC_URL,
          chain: sepolia,
        });
        const arrayBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);

        const result = await client.createAttestation({
          schemaId: 0xd9c6,
          data: {
            filename: file.name,
            fielData: Array.from(uint8Array),
            signer: address,
            timestamp: new Date().toISOString(),
            ...metadata,
          },
        });

        setState((prev) => ({
          ...prev,
          status: "success",
          signatureData: result,
        }));

        return result;
      } catch (error) {
        setState((prev) => ({
          ...prev,
          status: "error",
          error: {
            message: error.message,
            details: error.stack,
          },
        }));
        throw error;
      }
    },
    [initializeSDK]
  );

  const reset = useCallback(() => {
    if (state.documentPreview) {
      URL.revokeObjectURL(state.documentPreview);
    }
    setState({
      status: "idle",
      signatureData: null,
      error: null,
      documentPreview: null,
      isInitializing: false,
    });
  }, [state.documentPreview]);

  useEffect(() => {
    return () => {
      if (state.documentPreview) {
        URL.revokeObjectURL(state.documentPreview);
      }
    };
  }, [state.documentPreview]);

  return {
    ...state,
    prepareDocument,
    signPdf,
    reset,
    isSdkInitializing: state.isInitializing,
  };
}









































import { useState, useEffect, useCallback } from "react";
import { Buffer } from "buffer";
import { SignProtocolClient, SpMode } from "@ethsign/sp-sdk";
import { createPublicClient, http } from "viem";
import { Web3Provider } from "@ethersproject/providers";
import { sepolia } from "viem/chains";

if (typeof window !== "undefined" && !window.Buffer) {
  window.Buffer = Buffer;
}

export default function usePdfSigner2(options = {}) {
  const { file = null, walletAddress = null, metadata = {} } = options;

  const [state, setState] = useState({
    status: "idle",
    signatureData: null,
    error: null,
    documentPreview: null,
    isInitializing: false,
  });

  const prepareDocument = useCallback(
    async (file) => {
      try {
        setState((prev) => ({ ...prev, status: "preparing" }));

        if (
          !file?.type?.includes("pdf") &&
          !file?.name?.toLowerCase().endsWith(".pdf")
        ) {
          throw new Error("Only PDF files are supported");
        }

        if (state.documentPreview) {
          URL.revokeObjectURL(state.documentPreview);
        }

        const previewUrl = URL.createObjectURL(file);
        setState((prev) => ({
          ...prev,
          documentPreview: previewUrl,
          status: "ready_for_approval",
        }));

        return previewUrl;
      } catch (err) {
        setState((prev) => ({
          ...prev,
          status: "error",
          error: {
            message: err.message || "Failed to prepare document",
            details: err.stack,
          },
        }));
        throw err;
      }
    },
    [state.documentPreview]
  );

  // const initializeSDK = useCallback(async (opts) => {
  //   const {
  //     rpcUrl = import.meta.env.VITE_ALCHEMY_SEPOLIA_RPC_URL,
  //     chain = sepolia,
  //   } = opts || {}; // ✅ Safe destructuring

  //   const finalRpcUrl = rpcUrl || import.meta.env.VITE_ALCHEMY_SEPOLIA_RPC_URL;
  //   if (!finalRpcUrl) throw new Error("RPC URL is missing");

  //   try {
  //     if (!rpcUrl) throw new Error("RPC URL is missing from environment");

  //     const publicClient = createPublicClient({
  //       chain,
  //       transport: http(finalRpcUrl),
  //     });

  //     const provider = new Web3Provider(window.ethereum);
  //     await provider.send("eth_requestAccounts", []);
  //     const signer = await provider.getSigner();

  //     const client = new SignProtocolClient({
  //       mode: SpMode.OnChain,
  //       publicClient,
  //       signer,
  //       chain,
  //     });

  //     return client;
  //   } catch (error) {
  //     console.error("SDK initialization error:", error);
  //     throw new Error(`SDK initialization failed: ${error.message}`);
  //   }
  // }, []);
  const initializeSDK = useCallback(async (options) => {
    try {
      const opts = options || {}; // Ensure it's always an object

      // Use environment fallback if not provided in options
      const rpcUrl =
        opts.rpcUrl || import.meta.env.VITE_ALCHEMY_SEPOLIA_RPC_URL;
      const chain = opts.chain || sepolia;

      if (!rpcUrl) {
        throw new Error("RPC URL is missing from both options and environment");
      }

      const publicClient = createPublicClient({
        chain,
        transport: http(rpcUrl),
      });

      const provider = new Web3Provider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      const signer = await provider.getSigner();

      const client = new SignProtocolClient({
        mode: SpMode.OnChain,
        publicClient,
        signer,
        chain,
      });

      return client;
    } catch (error) {
      console.error("SDK initialization error:", error);
      throw new Error(`SDK initialization failed: ${error.message}`);
    }
  }, []);

  const signPdf = useCallback(
    async (file, address, metadata = {}) => {
      try {
        setState((prev) => ({ ...prev, status: "signing" }));

        const client = await initializeSDK(); // ✅ No arg or safe default
        const arrayBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);

        const result = await client.createAttestation({
          schemaId: 0xd9c6,
          data: {
            filename: file.name,
            fielData: Array.from(uint8Array),
            signer: address,
            timestamp: new Date().toISOString(),
            ...metadata,
          },
        });

        setState((prev) => ({
          ...prev,
          status: "success",
          signatureData: result,
        }));

        return result;
      } catch (error) {
        setState((prev) => ({
          ...prev,
          status: "error",
          error: {
            message: error.message,
            details: error.stack,
          },
        }));
        throw error;
      }
    },
    [initializeSDK]
  );

  const reset = useCallback(() => {
    if (state.documentPreview) {
      URL.revokeObjectURL(state.documentPreview);
    }
    setState({
      status: "idle",
      signatureData: null,
      error: null,
      documentPreview: null,
      isInitializing: false,
    });
  }, [state.documentPreview]);

  useEffect(() => {
    return () => {
      if (state.documentPreview) {
        URL.revokeObjectURL(state.documentPreview);
      }
    };
  }, [state.documentPreview]);

  return {
    ...state,
    prepareDocument,
    signPdf,
    reset,
    isSdkInitializing: state.isInitializing,
  };
}










  // return (
  //   <div
  //     style={{
  //       border: "1px solid #e2e8f0",
  //       borderRadius: "8px",
  //       padding: "16px",
  //       background: "white",
  //     }}
  //   >
  //     <div
  //       style={{
  //         display: "flex",
  //         justifyContent: "space-between",
  //         alignItems: "center",
  //         marginBottom: "12px",
  //       }}
  //     >
  //       <h3 style={{ margin: 0 }}>Document History</h3>
  //       {documents.length > 0 && (
  //         <button
  //           onClick={() => setShowClearConfirm(true)}
  //           style={{
  //             background: "none",
  //             border: "none",
  //             color: "#ef4444",
  //             cursor: "pointer",
  //             fontSize: "14px",
  //           }}
  //         >
  //           Clear All
  //         </button>
  //       )}
  //     </div>

  //     {showClearConfirm && (
  //       <div
  //         style={{
  //           padding: "12px",
  //           background: "#ffebee",
  //           borderRadius: "4px",
  //           marginBottom: "12px",
  //           display: "flex",
  //           justifyContent: "space-between",
  //         }}
  //       >
  //         <span>Are you sure?</span>
  //         <div>
  //           <button
  //             onClick={handleClear}
  //             style={{
  //               marginRight: "8px",
  //               background: "#ef4444",
  //               color: "white",
  //             }}
  //           >
  //             Confirm
  //           </button>
  //           <button onClick={() => setShowClearConfirm(false)}>Cancel</button>
  //         </div>
  //       </div>
  //     )}

  //     {documents.length === 0 ? (
  //       <p style={{ color: "#64748b", textAlign: "center" }}>
  //         No documents yet
  //       </p>
  //     ) : (
  //       <ul
  //         style={{
  //           listStyle: "none",
  //           padding: 0,
  //           margin: 0,
  //           maxHeight: "400px",
  //           overflowY: "auto",
  //         }}
  //       >
  //         {documents.map((doc, index) => (
  //           <li
  //             key={`${doc.id}-${index}`} // Ensures key is unique
  //             onClick={() => onSelect(doc)}
  //             style={{
  //               padding: "12px 8px",
  //               borderBottom: "1px solid #f1f5f9",
  //               cursor: "pointer",
  //               ":hover": {
  //                 background: "#f8fafc",
  //               },
  //             }}
  //           >
  //             <div
  //               style={{
  //                 display: "flex",
  //                 justifyContent: "space-between",
  //               }}
  //             >
  //               <strong
  //                 style={{
  //                   whiteSpace: "nowrap",
  //                   overflow: "hidden",
  //                   textOverflow: "ellipsis",
  //                   maxWidth: "180px",
  //                 }}
  //               >
  //                 {doc.name}
  //               </strong>
  //               <span
  //                 style={{
  //                   color: "#64748b",
  //                   fontSize: "0.8em",
  //                 }}
  //               >
  //                 {format(new Date(doc.timestamp), "MMM d, yyyy")}
  //               </span>
  //             </div>
  //             <div
  //               style={{
  //                 display: "flex",
  //                 alignItems: "center",
  //                 marginTop: "4px",
  //               }}
  //             >
  //               <span
  //                 style={{
  //                   display: "inline-block",
  //                   width: "8px",
  //                   height: "8px",
  //                   background: doc.verified ? "#10b981" : "#ef4444",
  //                   borderRadius: "50%",
  //                   marginRight: "6px",
  //                 }}
  //               />
  //               <span
  //                 style={{
  //                   fontSize: "0.8em",
  //                   color: doc.verified ? "#10b981" : "#ef4444",
  //                 }}
  //               >
  //                 {doc.verified ? "Verified" : "Pending"}
  //               </span>
  //             </div>
  //           </li>
  //         ))}
  //       </ul>
  //     )}
  //   </div>
  // );

