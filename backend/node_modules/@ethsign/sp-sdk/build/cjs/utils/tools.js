"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.throwApikeyError = void 0;
exports.delegateSignAttestation = delegateSignAttestation;
exports.delegateSignRevokeAttestation = delegateSignRevokeAttestation;
exports.delegateSignSchema = delegateSignSchema;
exports.checkId = checkId;
const viem_1 = require("viem");
const SignProtocolClient_1 = require("../SignProtocolClient");
const types_1 = require("../types");
const _1 = require(".");
async function delegateSignAttestation(attestation, options) {
    const client = new SignProtocolClient_1.SignProtocolClient(types_1.SpMode.OnChain, {
        chain: options?.chain,
        account: options?.delegationAccount,
        rpcUrl: options?.rpcUrl,
        walletClient: options?.walletClient,
    });
    const { schemaId, linkedAttestationId, data, validUntil, revoked, recipients, attester, indexingValue, } = attestation;
    const innerClient = client.getClient();
    const account = await innerClient.getAccount();
    if (!attestation.schemaId) {
        throw new Error('schemaId is required');
    }
    const dataLocation = attestation.dataLocation || types_1.DataLocationOnChain.ONCHAIN;
    const schema = (await client.getSchema(attestation.schemaId));
    const schemaData = schema?.data;
    if (!schema) {
        throw new Error('schema not found');
    }
    if (!(0, _1.validateObject)(data, schemaData)) {
        throw new Error('data is not valid');
    }
    const handledData = await (0, _1.uploadStorageData)({
        data,
        schema,
        apiKey: options?.apiKey,
        dataLocation,
    });
    const attestationData = {
        schemaId,
        linkedAttestationId: linkedAttestationId || 0,
        attester: attester || account?.address,
        validUntil: validUntil || 0,
        revoked: revoked || false,
        dataLocation,
        attestTimestamp: 0,
        revokeTimestamp: 0,
        recipients: recipients?.map((item) => {
            const isRecipientAddress = (0, viem_1.isAddress)(item);
            return (0, viem_1.encodeAbiParameters)([
                {
                    name: 'data',
                    type: isRecipientAddress &&
                        options?.recipientEncodingType === types_1.RecipientEncodingType.Address
                        ? types_1.RecipientEncodingType.Address
                        : types_1.RecipientEncodingType.String,
                },
            ], [item]);
        }) || [],
        data: (0, _1.encodeOnChainData)(handledData.data, dataLocation, handledData.schemaData),
    };
    const res = await innerClient.invokeContractRead('getDelegatedAttestHash', [
        attestationData,
    ]);
    const signature = await innerClient.signMessage(res);
    return {
        delegationSignature: signature,
        attestation: { ...attestationData, indexingValue },
    };
}
async function delegateSignRevokeAttestation(attestationId, options) {
    const client = new SignProtocolClient_1.SignProtocolClient(types_1.SpMode.OnChain, {
        chain: options?.chain,
        account: options?.delegationAccount,
        rpcUrl: options?.rpcUrl,
        walletClient: options?.walletClient,
    });
    const innerClient = client.getClient();
    const { reason } = options || {};
    const res = await innerClient.invokeContractRead('getDelegatedRevokeHash', [
        attestationId,
        reason || '',
    ]);
    const signature = await innerClient.signMessage(res);
    return {
        delegationSignature: signature,
        attestationId,
        reason: reason || '',
    };
}
async function delegateSignSchema(schema, options) {
    const client = new SignProtocolClient_1.SignProtocolClient(types_1.SpMode.OnChain, {
        chain: options?.chain,
        account: options?.delegationAccount,
        rpcUrl: options?.rpcUrl,
        walletClient: options?.walletClient,
    });
    const { revocable, maxValidFor, resolver, data, name, description, registrant, } = schema;
    const dataLocation = schema.dataLocation || types_1.DataLocationOnChain.ONCHAIN;
    const innerClient = client.getClient();
    const account = await innerClient.getAccount();
    const schemaData = {
        registrant: registrant || account.address,
        revocable: revocable === undefined ? true : revocable,
        dataLocation: dataLocation,
        maxValidFor: maxValidFor || 0,
        hook: resolver || '0x0000000000000000000000000000000000000000',
        timestamp: 0,
        data: dataLocation === types_1.DataLocationOnChain.ONCHAIN
            ? JSON.stringify({ name, description, data })
            : data,
    };
    const res = await innerClient.invokeContractRead('getDelegatedRegisterHash', [
        schemaData,
    ]);
    const signature = await innerClient.signMessage(res);
    return {
        delegationSignature: signature,
        schema: { ...schema, registrant: schemaData.registrant },
    };
}
//onchain_evm_7001_0x4
function checkId(id) {
    if (id.startsWith('SP')) {
        return true;
    }
    if (id.startsWith('0x')) {
        throw new Error('The id is invalid,Please go to Sign Scan to get the full ID');
    }
    const [type, chainType, chainId, ID] = id.split('_');
    if (type === 'onchain' && chainType && chainId && ID) {
        return true;
    }
    else {
        throw new Error('The id is invalid');
    }
}
const throwApikeyError = () => {
    throw new Error('Please provide apiKey which can get from https://developer.sign.global/');
};
exports.throwApikeyError = throwApikeyError;
//# sourceMappingURL=tools.js.map