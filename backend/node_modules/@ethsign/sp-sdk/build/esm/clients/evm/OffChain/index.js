import { ChainType } from '../../../types';
import { OffChainClientBase } from '../../../interface/OffChainClientBase';
import { http, createWalletClient, custom, } from 'viem';
import { mainnet } from 'viem/chains';
import { isBrowser } from '../../../utils';
export class EVMOffChainClient extends OffChainClientBase {
    walletClient;
    privateKeyAccount;
    account;
    constructor(options) {
        super({
            chainType: ChainType.evm,
            signType: options.signType,
            rpcUrl: options.rpcUrl,
            apiKey: options.apiKey,
        });
        if ('walletClient' in options) {
            this.walletClient = options.walletClient;
        }
        else if (options.account) {
            this.privateKeyAccount = options.account;
        }
        else {
            this.walletClient = createWalletClient({
                chain: mainnet,
                transport: isBrowser() && window.ethereum ? custom(window.ethereum) : http(),
            });
        }
    }
    async getAccount() {
        let account;
        if (this.privateKeyAccount) {
            account = this.privateKeyAccount;
        }
        else {
            const accounts = await this.walletClient.getAddresses();
            account = { address: accounts[0] };
        }
        return account;
    }
    async signTypedData({ message, types, primaryType, }) {
        const data = {
            domain: {
                name: 'sign.global',
                version: '1',
            },
            message: message,
            primaryType,
            types: {
                EIP712Domain: [
                    { name: 'name', type: 'string' },
                    { name: 'version', type: 'string' },
                ],
                ...types,
            },
        };
        const account = await this.getAccount();
        const signTypedData = this.privateKeyAccount
            ? account.signTypedData
            : this.walletClient.signTypedData;
        const signature = await signTypedData({
            account: account.address,
            ...data,
        });
        return {
            message: data,
            signature,
            publicKey: account.address,
        };
    }
    async signMessage(message) {
        const account = await this.getAccount();
        const signMessage = this.privateKeyAccount
            ? account.signMessage
            : this.walletClient.signMessage;
        const signature = await signMessage({
            account: account.address,
            message,
        });
        return {
            signature,
            message,
            publicKey: account.address,
        };
    }
}
//# sourceMappingURL=index.js.map