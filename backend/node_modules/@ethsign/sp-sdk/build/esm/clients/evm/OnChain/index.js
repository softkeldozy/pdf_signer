import { decodeAbiParameters, decodeEventLog, encodeAbiParameters, http, numberToHex, createPublicClient, createWalletClient, custom, isAddress, } from 'viem';
import { DataLocationOffChain, DataLocationOnChain, RecipientEncodingType, } from '../../../types';
import { decodeOnChainData, encodeOnChainData, getStorageData, isBrowser, uploadStorageData, validateObject, } from '../../../utils';
import { EvmChains } from '../types';
import { ContractInfoMap } from '../constants';
import abiJson from './abi/SignProtocol.json';
import { getDataFromStorage, saveSchemaToStorage } from '../../../services';
export class EVMOnChainClient {
    walletClient;
    publicClient;
    contractInfo;
    privateKeyAccount;
    chain;
    account;
    apiKey;
    constructor({ chain: chainType, rpcUrl: rpc, account: privateKeyAccount, walletClient, apiKey, }) {
        this.apiKey = apiKey;
        this.contractInfo = chainType
            ? ContractInfoMap[chainType]
            : ContractInfoMap[EvmChains.sepolia];
        const chain = {
            ...this.contractInfo?.chain,
            rpcUrls: rpc
                ? {
                    default: {
                        http: [rpc],
                    },
                }
                : this.contractInfo?.chain.rpcUrls,
        };
        this.chain = chain;
        // @ts-ignore
        this.publicClient = createPublicClient({
            chain,
            transport: http(),
        });
        this.walletClient =
            walletClient ||
                createWalletClient({
                    chain,
                    transport: privateKeyAccount
                        ? http()
                        : isBrowser() && window.ethereum
                            ? custom(window.ethereum)
                            : http(),
                });
        this.privateKeyAccount = privateKeyAccount;
    }
    async signMessage(message) {
        const account = await this.getAccount();
        return await this.walletClient.signMessage({
            account: this.privateKeyAccount ? account : account.address,
            message: { raw: message },
        });
    }
    async switchChain() {
        const walletChainId = await this.walletClient.getChainId();
        if (walletChainId !== this.chain.id) {
            try {
                await this.walletClient.switchChain({
                    id: this.chain.id,
                });
            }
            catch (error) {
                if (error?.code !== 4001) {
                    await this.walletClient.addChain({
                        chain: this.chain,
                    });
                    await this.walletClient.switchChain({
                        id: this.chain.id,
                    });
                }
            }
        }
    }
    async getAccount() {
        let account;
        if (this.privateKeyAccount) {
            account = this.privateKeyAccount;
        }
        else {
            const accounts = await this.walletClient.getAddresses();
            account = { address: accounts[0] };
        }
        return account;
    }
    async invokeContractRead(functionName, args = []) {
        try {
            return this.publicClient.readContract({
                address: this.contractInfo.address,
                abi: abiJson.abi,
                functionName,
                args,
            });
        }
        catch (error) {
            console.error(error.message);
            throw error;
        }
    }
    async invokeContractWrite(functionName, args = [], value, abi, gas) {
        try {
            const account = await this.getAccount();
            await this.switchChain();
            const data = {
                account: this.privateKeyAccount ? account : account.address,
                address: this.contractInfo.address,
                abi: abi || abiJson.abi,
                functionName,
                args,
                value,
                chain: this.chain,
                gas,
            };
            const { request } = await this.publicClient.simulateContract(data);
            return this.walletClient.writeContract(request);
        }
        catch (error) {
            console.error(error.message);
            throw error;
        }
    }
    async createSchema(schema, options) {
        const { revocable, maxValidFor, resolver, hook, data, name, description, registrant, } = schema;
        const account = await this.getAccount();
        const dataLocation = schema.dataLocation || DataLocationOnChain.ONCHAIN;
        const { delegationSignature, getTxHash, gas } = options || {};
        let newData = data;
        if (dataLocation !== DataLocationOnChain.ONCHAIN) {
            newData = await saveSchemaToStorage({
                data,
                name,
                description,
                dataLocation: dataLocation === DataLocationOnChain.ARWEAVE
                    ? DataLocationOffChain.ARWEAVE
                    : DataLocationOffChain.IPFS,
                apiKey: this.apiKey,
            });
        }
        const txHash = await this.invokeContractWrite('register', [
            {
                registrant: registrant || account.address,
                revocable: revocable === undefined ? true : revocable,
                dataLocation: dataLocation,
                maxValidFor: maxValidFor || 0,
                hook: hook || resolver || '0x0000000000000000000000000000000000000000',
                timestamp: 0,
                data: dataLocation === DataLocationOnChain.ONCHAIN
                    ? JSON.stringify({ name, description, data: newData })
                    : newData,
            },
            delegationSignature || '',
        ], undefined, undefined, gas);
        getTxHash && getTxHash(txHash);
        const res = await this.publicClient.waitForTransactionReceipt({
            hash: txHash,
        });
        const decodedLog = decodeEventLog({
            abi: abiJson.abi,
            topics: res.logs[0].topics,
            data: res.logs[0].data,
        });
        const schemaId = numberToHex(decodedLog.args.schemaId);
        return { schemaId, txHash };
    }
    async getSchema(schemaId) {
        const res = await this.invokeContractRead('getSchema', [schemaId]);
        if (res.data === '') {
            throw new Error('schema not found');
        }
        const { revocable, dataLocation, maxValidFor, resolver, hook, data, timestamp, } = res;
        const isOnChain = dataLocation === DataLocationOnChain.ONCHAIN;
        let dataObj;
        if (isOnChain) {
            dataObj = JSON.parse(data);
        }
        else if (dataLocation === DataLocationOnChain.ARWEAVE ||
            dataLocation === DataLocationOnChain.IPFS) {
            const res = await getDataFromStorage({ dataId: data, dataLocation });
            dataObj = res.data;
        }
        const result = {
            name: dataObj.name,
            description: dataObj.description,
            revocable,
            dataLocation,
            timestamp: Number(timestamp),
            maxValidFor: Number(maxValidFor),
            hook: hook || resolver,
            data: dataObj.data,
            registrant: res.registrant,
        };
        return result;
    }
    async revokeAttestation(attestationId, options) {
        const { reason, delegationSignature, getTxHash, resolverFeesETH, extraData, resolverFeesERC20Token, resolverFeesERC20Amount, gas, } = options || {};
        const params = [
            attestationId,
            reason || '',
            delegationSignature || '',
            extraData || '',
        ];
        const revokeAbis = abiJson.abi.filter((item) => item.name === 'revoke');
        let revokeAbi = [revokeAbis[0]];
        if (resolverFeesERC20Token && resolverFeesERC20Amount) {
            params.splice(2, 0, resolverFeesERC20Token, resolverFeesERC20Amount);
            revokeAbi = [revokeAbis[1]];
        }
        if (resolverFeesETH) {
            params.splice(2, 0, resolverFeesETH);
            revokeAbi = [revokeAbis[2]];
        }
        const txHash = await this.invokeContractWrite('revoke', params, resolverFeesETH, [...revokeAbi, ...abiJson.abi], gas);
        getTxHash && getTxHash(txHash);
        const res = await this.publicClient.waitForTransactionReceipt({
            hash: txHash,
        });
        const decodedLog = decodeEventLog({
            abi: abiJson.abi,
            topics: res.logs[0].topics,
            data: res.logs[0].data,
        });
        const id = numberToHex(decodedLog.args.attestationId);
        return { attestationId: id, txHash, reason: decodedLog.args.reason };
    }
    async createAttestation(attestation, options) {
        const { schemaId, linkedAttestationId, data, validUntil, revoked, recipients, indexingValue, attester, attestTimestamp, revokeTimestamp, } = attestation;
        const { delegationSignature, getTxHash, resolverFeesETH, recipientEncodingType, extraData, resolverFeesERC20Token, resolverFeesERC20Amount, gas, } = options || {};
        const dataLocation = attestation.dataLocation || DataLocationOnChain.ONCHAIN;
        let attestationData;
        if (delegationSignature) {
            attestationData = {
                schemaId,
                linkedAttestationId,
                data,
                validUntil: BigInt(validUntil || 0),
                revoked,
                recipients,
                attester,
                dataLocation,
                attestTimestamp,
                revokeTimestamp,
            };
        }
        else {
            const account = await this.getAccount();
            if (!attestation.schemaId) {
                throw new Error('schemaId is required');
            }
            const schema = await this.getSchema(attestation.schemaId);
            const schemaData = schema?.data;
            if (!schema) {
                throw new Error('schema not found');
            }
            if (!validateObject(data, schemaData)) {
                throw new Error('data is not valid');
            }
            const handledData = await uploadStorageData({
                data,
                schema,
                apiKey: this.apiKey,
                dataLocation,
            });
            attestationData = {
                schemaId,
                linkedAttestationId: linkedAttestationId || '',
                attester: attester || account.address,
                validUntil: BigInt(validUntil || 0),
                revoked: revoked || false,
                dataLocation,
                attestTimestamp: 0,
                revokeTimestamp: 0,
                recipients: recipients?.map((item) => {
                    const isRecipientAddress = isAddress(item);
                    return encodeAbiParameters([
                        {
                            name: 'data',
                            type: isRecipientAddress &&
                                recipientEncodingType === RecipientEncodingType.Address
                                ? RecipientEncodingType.Address
                                : RecipientEncodingType.String,
                        },
                    ], [item]);
                }) || [],
                data: encodeOnChainData(handledData.data, dataLocation, handledData.schemaData),
            };
        }
        const params = [
            attestationData,
            indexingValue || '',
            delegationSignature || '',
            extraData || '',
        ];
        const attestAbis = abiJson.abi.filter((item) => item.name === 'attest');
        let attestAbi = [attestAbis[0]];
        if (resolverFeesETH) {
            params.splice(1, 0, resolverFeesETH);
            attestAbi = [attestAbis[2]];
        }
        if (resolverFeesERC20Token && resolverFeesERC20Amount) {
            params.splice(1, 0, resolverFeesERC20Token, resolverFeesERC20Amount);
            attestAbi = [attestAbis[1]];
        }
        const txHash = await this.invokeContractWrite('attest', params, resolverFeesETH, [...attestAbi, ...abiJson.abi], gas);
        getTxHash && getTxHash(txHash);
        const res = await this.publicClient.waitForTransactionReceipt({
            hash: txHash,
        });
        const decodedLog = decodeEventLog({
            abi: abiJson.abi,
            topics: res.logs[0].topics,
            data: res.logs[0].data,
        });
        const attestationId = numberToHex(decodedLog.args.attestationId);
        return {
            attestationId,
            txHash,
            indexingValue: decodedLog.args.indexingKey,
        };
    }
    async getAttestation(attestationId) {
        const res = await this.invokeContractRead('getAttestation', [
            attestationId,
        ]);
        if (res.data === '0x') {
            throw new Error('attestation not found');
        }
        const schemaId = numberToHex(res.schemaId);
        const schema = await this.getSchema(schemaId);
        const schemaData = schema.data;
        const data = decodeOnChainData(res.data, res.dataLocation, schemaData);
        const handledData = await getStorageData({
            data,
            schema,
            dataLocation: res.dataLocation,
        });
        const recipients = res.recipients.map((item) => {
            let res;
            try {
                res = decodeAbiParameters([{ name: 'data', type: RecipientEncodingType.String }], item)[0];
            }
            catch (error) {
                res = decodeAbiParameters([{ name: 'data', type: RecipientEncodingType.Address }], item)[0];
            }
            return res;
        });
        const result = {
            attestTimestamp: Number(res.attestTimestamp),
            revokeTimestamp: Number(res.revokeTimestamp),
            schemaId,
            data: handledData.data,
            recipients,
            revoked: res.revoked,
            dataLocation: res.dataLocation,
            validUntil: Number(res.validUntil),
            linkedAttestationId: '0x' + Number(res.linkedAttestationId).toString(16) || '',
            indexingValue: res.indexingKey,
            attester: res.attester,
        };
        return result;
    }
}
//# sourceMappingURL=index.js.map