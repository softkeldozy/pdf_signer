import { ChainType } from '../../../types';
import { OffChainClientBase } from '../../../interface/OffChainClientBase';
import { sign } from '@ton/crypto';
import { WalletContractV5R1, WalletContractV4, Address } from '@ton/ton';
import { sha256 } from '@noble/hashes/sha256';
import { Buffer } from 'buffer';
export class TonOffChainClient extends OffChainClientBase {
    walletClient;
    keyPair;
    address;
    proofAnchor;
    constructor(options) {
        super({
            chainType: ChainType.ton,
            signType: options.signType,
            apiKey: options.apiKey,
            rpcUrl: options.rpcUrl,
        });
        if ('walletClient' in options) {
            this.walletClient = options.walletClient;
        }
        else {
            if (options.account && !options.walletAddress) {
                throw new Error('walletAddress is required when account is provided');
            }
            this.keyPair = options.account;
            this.address = options.walletAddress;
        }
    }
    async getAccount() {
        if (this.keyPair) {
            const publicKey = this.keyPair.publicKey;
            const walletV5 = await WalletContractV5R1.create({
                publicKey: publicKey,
                workchain: 0,
            });
            const addressV5 = walletV5.address.toString({ bounceable: false });
            const walletV4 = await WalletContractV4.create({
                publicKey: publicKey,
                workchain: 0,
            });
            const addressV4 = walletV4.address.toString({ bounceable: false });
            if (addressV4 !== this.address && addressV5 !== this.address) {
                throw new Error('walletAddress is not match with account');
            }
            return {
                address: this.address,
                publicKey: this.keyPair.publicKey.toString('hex'),
            };
        }
        else {
            const { address, publicKey } = this.walletClient.account || {};
            const parsedAddress = Address.parse(address).toString({
                bounceable: false,
            });
            return {
                address: parsedAddress,
                publicKey,
            };
        }
    }
    async signMessage(message) {
        const hash = sha256(message);
        const payload = Buffer.from(hash).toString('hex');
        let signature;
        let fullMessage;
        if (this.keyPair) {
            fullMessage = {
                timestamp: Math.floor(Date.now() / 1000),
                payload,
                domain: {
                    lengthBytes: 11,
                    value: 'sign.global',
                },
            };
            const fullMessageForTonConnect = buildFullMessageForTonConnect(Address.parse(this.address), fullMessage);
            signature = await sign(fullMessageForTonConnect, this.keyPair.secretKey);
        }
        else if (this.walletClient) {
            this.proofAnchor = Date.now();
            this.walletClient.setConnectRequestParameters({
                state: 'ready',
                value: {
                    tonProof: payload,
                },
            });
            const currentAppName = this.walletClient.wallet?.appName;
            const wallets = await this.walletClient.getWallets();
            const currentWallet = wallets.find((wallet) => [wallet.name, wallet.appName].includes(currentAppName));
            if (this.walletClient.wallet) {
                await this.walletClient.disconnect();
            }
            if (currentAppName) {
                const universalLink = this.walletClient.connector.connect(currentWallet, {
                    tonProof: payload,
                });
                if (currentAppName === 'telegram-wallet') {
                    window.open(universalLink, '_blank');
                }
            }
            else {
                this.walletClient.openModal();
            }
            const proof = await new Promise((resolve, reject) => {
                const proofAnchor = this.proofAnchor;
                return this.walletClient.onStatusChange((walletInfo) => {
                    let tonProof = walletInfo?.connectItems?.tonProof;
                    if (tonProof?.proof && proofAnchor === this.proofAnchor) {
                        resolve(tonProof?.proof);
                    }
                    else {
                        reject('wallet modal closed');
                    }
                }, (err) => { });
            });
            signature = proof.signature;
            fullMessage = {
                timestamp: proof.timestamp,
                payload: proof.payload,
                domain: proof.domain,
            };
        }
        else {
            throw new Error('No wallet client found');
        }
        const account = await this.getAccount();
        // 将签名转换为Base64或十六进制字符串
        return {
            signature: signature.toString('base64'),
            message: JSON.stringify(fullMessage),
            publicKey: account.publicKey,
        };
    }
    signTypedData(data) {
        throw new Error('Method not implemented for TON.');
    }
}
function buildFullMessageForTonConnect(addr, message) {
    const tonProofPrefix = 'ton-proof-item-v2/';
    const tonConnectPrefix = 'ton-connect';
    const wc = Buffer.alloc(4);
    wc.writeUInt32BE(addr.workChain);
    const ts = Buffer.alloc(8);
    ts.writeBigUInt64LE(BigInt(message.timestamp));
    const dl = Buffer.alloc(4);
    dl.writeUInt32LE(message.domain.lengthBytes);
    const m = Buffer.concat([
        Buffer.from(tonProofPrefix),
        wc,
        addr.hash,
        dl,
        Buffer.from(message.domain.value),
        ts,
        Buffer.from(message.payload),
    ]);
    const messageHash = sha256(m);
    const fullMes = Buffer.concat([
        Buffer.from([0xff, 0xff]),
        Buffer.from(tonConnectPrefix),
        Buffer.from(messageHash),
    ]);
    const res = sha256(fullMes);
    return Buffer.from(res);
}
//# sourceMappingURL=index.js.map