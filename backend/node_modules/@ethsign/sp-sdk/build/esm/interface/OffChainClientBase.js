import { isAddress } from 'viem';
import { OffChainRpc } from '../types/offChain';
import { DataLocationOffChain, OffChainSignType, } from '../types';
import { request, validateObject } from '../utils';
import { throwApikeyError } from '../utils/tools';
export class OffChainClientBase {
    rpcUrl;
    chainType;
    signType;
    apiKey;
    constructor({ chainType, signType, rpcUrl, apiKey, }) {
        this.rpcUrl = rpcUrl || OffChainRpc.mainnet;
        this.signType = signType;
        this.chainType = chainType;
        this.apiKey = apiKey;
    }
    async revokeAttestation(attestationId, options) {
        if (!this.apiKey) {
            throwApikeyError();
        }
        const { reason } = options || {};
        let publicKey;
        const signType = this.signType;
        const revokeAttestationObj = {
            attestationId,
            reason: reason || '',
        };
        const revokeAttestationString = JSON.stringify(revokeAttestationObj);
        let signature = '';
        let message = revokeAttestationString;
        if (signType === OffChainSignType.EvmEip712) {
            const info = await this.signTypedData({
                message: revokeAttestationObj,
                types: {
                    Data: [
                        { name: 'attestationId', type: 'string' },
                        { name: 'reason', type: 'string' },
                    ],
                },
                primaryType: 'Data',
            });
            signature = info.signature;
            message = JSON.stringify(info.message);
            publicKey = info.publicKey;
        }
        else {
            const res = await this.signMessage(revokeAttestationString);
            signature = res.signature;
            message = res.message;
            publicKey = res.publicKey;
        }
        const url = this.rpcUrl + '/sp/revoke-attestation';
        try {
            const res = await request(url, {
                method: 'POST',
                headers: {
                    'x-sign-api-key': this.apiKey || '',
                },
                body: JSON.stringify({
                    signType,
                    publicKey,
                    signature,
                    message,
                    revokeInfo: revokeAttestationString,
                }),
            });
            if (res) {
                return { attestationId, reason };
            }
            else {
                throw new Error('revoke attestation failed');
            }
        }
        catch (error) {
            // 传递后端返回的具体错误信息
            if (error.errorData) {
                throw error;
            }
            throw new Error('revoke attestation failed');
        }
    }
    async createSchema(schema) {
        if (!this.apiKey) {
            throwApikeyError();
        }
        let publicKey;
        const signType = this.signType;
        const { name, description, revocable, maxValidFor, data, dataLocation = DataLocationOffChain.ARWEAVE, } = schema;
        const schemaObj = {
            name: name || '',
            description: description || '',
            revocable: revocable === undefined ? true : revocable,
            maxValidFor: maxValidFor || 0,
            types: data,
            dataLocation,
        };
        const schemaString = JSON.stringify(schemaObj);
        let signature = '';
        let message = schemaString;
        if (signType === OffChainSignType.EvmEip712) {
            const info = await this.signTypedData({
                message: schemaObj,
                types: {
                    Data: [
                        { name: 'name', type: 'string' },
                        { name: 'description', type: 'string' },
                        { name: 'revocable', type: 'bool' },
                        { name: 'maxValidFor', type: 'uint32' },
                        { name: 'dataLocation', type: 'string' },
                        { name: 'types', type: 'SchemaItem[]' },
                    ],
                    SchemaItem: [
                        { name: 'name', type: 'string' },
                        { name: 'type', type: 'string' },
                    ],
                },
                primaryType: 'Data',
            });
            signature = info.signature;
            message = JSON.stringify(info.message);
            publicKey = info.publicKey;
        }
        else {
            const res = await this.signMessage(schemaString);
            signature = res.signature;
            message = res.message;
            publicKey = res.publicKey;
        }
        const url = this.rpcUrl + '/sp/schemas';
        const res = await request(url, {
            method: 'POST',
            headers: {
                'x-sign-api-key': this.apiKey || '',
            },
            body: JSON.stringify({
                signType,
                publicKey,
                signature,
                message,
                schema: schemaString,
            }),
        });
        return res.data;
    }
    async getSchema(schemaId) {
        const url = this.rpcUrl + '/sp/schemas/' + schemaId;
        const res = await request(url, {
            method: 'GET',
        });
        if (!res.data) {
            throw new Error('schema not found');
        }
        const { name, description, revocable, dataLocation, maxValidFor, resolver, data, } = res.data;
        const result = {
            name,
            description,
            revocable,
            dataLocation,
            maxValidFor,
            resolver,
            data,
        };
        return result;
    }
    async createAttestation(attestation) {
        if (!this.apiKey) {
            throwApikeyError();
        }
        let publicKey;
        const signType = this.signType;
        const { schemaId, linkedAttestationId, validUntil, recipients, indexingValue, data, dataLocation = DataLocationOffChain.ARWEAVE, } = attestation;
        const attestationObj = {
            schemaId,
            linkedAttestationId: linkedAttestationId || '',
            validUntil: validUntil || 0,
            recipients: recipients || [],
            indexingValue,
            dataLocation,
            data: JSON.stringify(data),
        };
        const attestationString = JSON.stringify(attestationObj);
        const schema = await this.getSchema(schemaId);
        const schemaData = schema?.data;
        if (!schema) {
            throw new Error('schema not found');
        }
        if (!validateObject(data, schemaData)) {
            throw new Error('data is not valid');
        }
        let signature = '';
        let message = attestationString;
        if (signType === OffChainSignType.EvmEip712) {
            let isRecipientAddress = true;
            recipients?.forEach((recipient) => {
                if (!isAddress(recipient)) {
                    isRecipientAddress = false;
                }
            });
            const info = await this.signTypedData({
                message: attestationObj,
                types: {
                    AttestationData: schemaData,
                    Data: [
                        { name: 'schemaId', type: 'string' },
                        { name: 'linkedAttestationId', type: 'string' },
                        { name: 'data', type: 'string' },
                        { name: 'validUntil', type: 'uint32' },
                        {
                            name: 'recipients',
                            type: isRecipientAddress ? 'address[]' : 'string[]',
                        },
                        {
                            name: 'indexingValue',
                            type: isAddress(indexingValue) ? 'address' : 'string',
                        },
                    ],
                },
                primaryType: 'Data',
            });
            signature = info.signature;
            message = JSON.stringify(info.message);
            publicKey = info.publicKey;
        }
        else {
            const res = await this.signMessage(attestationString);
            signature = res.signature;
            message = res.message;
            publicKey = res.publicKey;
        }
        const url = this.rpcUrl + '/sp/attestations';
        const res = await request(url, {
            method: 'POST',
            headers: {
                'x-sign-api-key': this.apiKey || '',
            },
            body: JSON.stringify({
                signType,
                publicKey,
                signature,
                message,
                attestation: attestationString,
            }),
        });
        return res.data;
    }
    async getAttestation(attestationId) {
        const url = this.rpcUrl + '/index/attestations/' + attestationId;
        const res = await request(url, {
            method: 'GET',
        });
        if (!res.data) {
            throw new Error('attestation not found');
        }
        const { schemaId, linkedAttestationId, data, validUntil, revoked, recipients, indexingValue, } = res.data;
        const result = {
            schemaId,
            linkedAttestationId,
            data: data ? JSON.parse(data) : data,
            validUntil,
            revoked,
            recipients,
            indexingValue,
        };
        return result;
    }
}
//# sourceMappingURL=OffChainClientBase.js.map