import { ChainType } from '../../../types';
import { OffChainClientBase } from '../../../interface/OffChainClientBase';
import {
  PrivateKeyAccount,
  WalletClient,
  http,
  createWalletClient,
  custom,
} from 'viem';
import { mainnet } from 'viem/chains';
import { EVMOffChainClientOptions } from '../types';
import { isBrowser } from '../../../utils';

export class EVMOffChainClient extends OffChainClientBase {
  public walletClient?: WalletClient;
  public privateKeyAccount?: PrivateKeyAccount;
  public account!: { address: `0x${string}` };
  constructor(options: EVMOffChainClientOptions) {
    super({
      chainType: ChainType.evm,
      signType: options.signType,
      rpcUrl: options.rpcUrl,
      apiKey: options.apiKey,
    });

    if ('walletClient' in options) {
      this.walletClient = options.walletClient;
    } else if (options.account) {
      this.privateKeyAccount = options.account as PrivateKeyAccount;
    } else {
      this.walletClient = createWalletClient({
        chain: mainnet,
        transport:
          isBrowser() && window.ethereum ? custom(window.ethereum) : http(),
      });
    }
  }

  public async getAccount() {
    let account;
    if (this.privateKeyAccount) {
      account = this.privateKeyAccount;
    } else {
      const accounts = await this.walletClient!.getAddresses();
      account = { address: accounts[0] } as PrivateKeyAccount;
    }
    return account;
  }

  async signTypedData({
    message,
    types,
    primaryType,
  }: {
    message: { [key: string]: any };
    types: { [key: string]: { name: string; type: string }[] };
    primaryType: string;
  }): Promise<{ message: any; signature: string; publicKey: string }> {
    const data: any = {
      domain: {
        name: 'sign.global',
        version: '1',
      } as const,
      message: message,
      primaryType,
      types: {
        EIP712Domain: [
          { name: 'name', type: 'string' },
          { name: 'version', type: 'string' },
        ],
        ...types,
      } as const,
    };
    const account = await this.getAccount();
    const signTypedData: any = this.privateKeyAccount
      ? account.signTypedData
      : this.walletClient!.signTypedData;
    const signature = await signTypedData({
      account: account.address,
      ...data,
    });
    return {
      message: data,
      signature,
      publicKey: account.address,
    };
  }

  async signMessage(
    message: string
  ): Promise<{ signature: string; message: string; publicKey: string }> {
    const account = await this.getAccount();
    const signMessage = this.privateKeyAccount
      ? account.signMessage
      : this.walletClient!.signMessage;
    const signature = await signMessage({
      account: account.address,
      message,
    });
    return {
      signature,
      message,
      publicKey: account.address,
    };
  }
}
