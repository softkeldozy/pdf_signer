import { ChainType, OffChainSignType } from '../../../types';
import { OffChainClientBase } from '../../../interface/OffChainClientBase';
import { SolanaOffChainClientOptions, SolanaWalletClient } from '../types';
import { Keypair } from '@solana/web3.js';
import * as ed from '@noble/ed25519';
import bs58 from 'bs58';
export class SolanaOffChainClient extends OffChainClientBase {
  public walletClient!: SolanaWalletClient;
  public keyPair?: Keypair;
  constructor(options: SolanaOffChainClientOptions) {
    super({
      chainType: ChainType.solana,
      signType: options.signType,
      rpcUrl: options.rpcUrl,
      apiKey: options.apiKey,
    });
    if ('walletClient' in options) {
      this.walletClient = options.walletClient;
    } else {
      this.keyPair = options.account;
    }
  }

  public async getAccount() {
    if (this.keyPair) {
      const address = this.keyPair.publicKey.toBase58();
      return {
        address: address,
      };
    } else {
      return { address: this.walletClient.publicKey!.toBase58() };
    }
  }

  async signMessage(
    message: string
  ): Promise<{ signature: string; message: string; publicKey: string }> {
    const messageBytes = new TextEncoder().encode(message);
    const signMessage = this.keyPair
      ? await ed.sign(messageBytes, this.keyPair.secretKey.slice(0, 32))
      : await this.walletClient.signMessage!(messageBytes);
    const account = await this.getAccount();
    return {
      signature: bs58.encode(signMessage),
      message: message,
      publicKey: account.address,
    };
  }

  signTypedData(data: {
    message: { [key: string]: any };
    types: { [key: string]: { name: string; type: string }[] };
    primaryType: string;
  }): Promise<{ message: any; signature: string; publicKey: string }> {
    throw new Error('Method not implemented.');
  }
}
